\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{float}
\usepackage{fancyhdr} % Paquete para encabezados personalizados
\usepackage{parskip}
\usepackage{tcolorbox}
\usepackage{bold-extra}
\usepackage{array} % Para definir ancho de columnas y word wrapping
\usepackage{makecell} % Para ajustar texto dentro de las celdas
\usepackage{ulem}
\usepackage{biblatex}
\addbibresource{referencias.bib}  % Archivo de referencias



\setcounter{tocdepth}{2}
\setlength{\parskip}{1em}  % Ajusta la distancia entre párrafos
\setlist[itemize]{noitemsep}
%\setlist[enumerate]{noitemsep}
\captionsetup[figure]{labelfont=bf}
\captionsetup[table]{labelfont=bf}
\geometry{margin=1.3in, headheight=30pt}
\addtolength{\topmargin}{-6.23604pt}

\title{Desarrollo de un sistema de programación automatizada de tareas de mantenimiento en la industria minera}
\date{}

\pagestyle{fancy} 
\fancyhf{} 
\lhead{\includegraphics[width=6cm]{imgs/UC Logo.png}\vspace{1.5mm}} 
\rhead{Emilio Bravo Maturana\\
Magíster en Inteligencia Artificial (c)\vspace{3.5mm}}
\renewcommand{\headrulewidth}{0.4pt} 
\cfoot{\thepage} % Número de página centrado en el pie de página
\renewcommand{\footrulewidth}{0.4pt} % Línea en el pie de página (opcional)

\begin{document}

\begin{titlepage}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\center
\textsc{\LARGE Pontificia Universidad Católica de Chile}\\[1cm] 
\textsc{\large Magister en Inteligencia Artificial}\\[0.5cm] 
\HRule \\[0.4cm]
\huge \textsc{Desarrollo de un sistema de programación automatizada de tareas de mantenimiento en la industria minera}\\[0.1cm]
\HRule \\[1cm]
\large\textsc{Emilio Bravo Maturana\\\emph{Profesor Guía: }Rodrigo Sandoval Urrich}\\[1cm]
\includegraphics[scale=0.2]{imgs/UC Logo Grande.png}\\[1cm]
\vfill
{\large\emph{Santiago, Chile. \\ Diciembre 2024 }}\\[2cm]


\end{titlepage}

{\bfseries\scshape Título}\\[.25cm]
Desarrollo de un sistema de programación automatizada de tareas de mantenimiento en la industria minera.\\


{\bfseries\scshape Autor}\\[.25cm]
Emilio Bravo Maturana\\

{\bfseries\scshape Temática}\\[.25cm]
Programación de Tareas, Mantenimiento Industrial, Algoritmos de Optimización, Resource-Constrained Project Scheduling Problem (RCPSP), Constraint Programming (CP).

\newpage

\section*{Resumen}
El mantenimiento eficiente de equipos es crucial para garantizar la continuidad operativa en cualquier industria. Sin embargo, la programación manual de estas actividades es compleja, intensiva en tiempo y propensa a errores debido a las múltiples restricciones y variables involucradas. Esto genera una alta dependencia de personal especializado para llevar a cabo la programación de tareas.

Este proyecto tiene como objetivo principal automatizar el proceso de programación de tareas de mantenimiento, liberando al equipo de programación de trabajo manual intensivo y reduciendo significativamente la ocurrencia de errores. Para ello, el problema se modela como un Problema de Programación de Proyectos con Restricciones de Recursos (RCPSP). Una generalización correcta del proceso permite utilizar herramientas de Programación por Restricciones (CP) para generar cronogramas que cumplan con todas las restricciones del problema, minimizando el \textit{makespan} y las tareas no programadas.

El objetivo central de este trabajo es desarrollar una solución que permita (1) liberar al equipo de programación de tareas manuales intensivas, optimizando su tiempo y esfuerzo y (2) reducir los errores en las labores de mantenimiento, especialmente aquellos derivados de programaciones deficientes.

A partir de un dataset de 4.898 tareas, nuestra solución es capaz de generar un cronograma programando el 98,6\% de las tareas con un \textit{makespan} de 21,5 días y con tiempo de procesamiento de 6,1 segundos.
\newpage

\tableofcontents
\newpage
%\maketitle 
%\vspace{-10mm}
%\thispagestyle{fancy} 

\section{Introducción}
\subsection{Contexto}
El mantenimiento de equipos es una actividad fundamental en cualquier industria que busca garantizar la continuidad operativa y la eficiencia en sus procesos productivos. Una planificación y programación adecuada de las actividades de mantenimiento no solo previene fallos inesperados en los equipos, sino que también optimiza el uso de recursos y minimiza costos asociados a tiempos de inactividad. Sin embargo, la programación eficiente de estas actividades representa un desafío significativo debido a las múltiples restricciones y variables involucradas, como la disponibilidad de personal, recursos materiales y prioridades de tareas.

Tradicionalmente, la planificación del mantenimiento ha dependido de equipos humanos que, a pesar de su experiencia y conocimiento, enfrentan limitaciones en términos de tiempo y capacidad para manejar grandes volúmenes de datos y restricciones complejas. Este proceso manual es propenso a errores y puede no garantizar una solución óptima que maximice la eficiencia operativa. En este contexto, surge la necesidad de automatizar este proceso mediante el uso de algoritmos de optimización que puedan abordar de manera efectiva la complejidad inherente de la programación de mantenimiento.

El problema de programación de mantenimiento puede modelarse como un Problema de Programación de Proyectos con Restricciones de Recursos (RCPSP por sus siglas en inglés), un enfoque de investigación operativa para resolver problemas de planificación bajo condiciones de recursos limitados. En este modelo, las tareas de mantenimiento se consideran actividades con duraciones definidas, precedencias entre ellas y recursos compartidos, como personal y maquinaria, cuya disponibilidad es limitada. Generalmente el objetivo es encontrar una programación que minimice el tiempo total de ejecución (\textit{makespan}). Modelar el problema de esta forma permite aplicar algoritmos de optimización avanzados, como algoritmos de Programació por Restricciones (CP por sus siglas en inglés), para generar soluciones factibles y eficientes.

El presente proyecto tiene como objetivo principal proponer un algoritmo para automatizar la programación de actividades de mantenimiento, que permita (1) liberar al equipo de programación de tareas manuales intensivas, optimizando su tiempo y esfuerzo y (2) reducir los errores en las labores de mantenimiento, especialmente aquellos derivados de programaciones deficientes. 

Se evaluarán distintas funciones objetivo para determinar cuál entrega los mejores resultados en términos de calidad de las soluciones generadas y tiempo de procesamiento. Para ello, se contará con el apoyo del área de mantenimiento de una empresa colaboradora del rubro minero, quienes proporcionarán datos para realizar las pruebas y ofrecerán retroalimentación durante el desarrollo de la solución. Esta colaboración permitirá ajustar el modelo a las necesidades específicas y desafíos particulares del entorno operativo, asegurando que los resultados sean relevantes y aplicables.


\subsection{Consideraciones}
Es importante contextualizar la terminología específica utilizada en la programación de tareas en la empresa colaboradora. A continuación, se definen algunos términos relevantes para facilitar la comprensión del problema.

% \textbf{Cronograma}: El cronograma es la representación temporal de la programación de todas las actividades a lo largo del tiempo. En este proyecto, el cronograma se materializa en una carta GANTT que muestra todas las tareas con su fecha de inicio, hora de inicio y duración. Es una herramienta clave para visualizar y gestionar la ejecución del mantenimiento.

\textbf{Orden de Trabajo}: Una orden de trabajo es un conjunto de tareas que se deben realizar para cumplir con un objetivo específico, como el mantenimiento de un equipo o vehículo. Estas órdenes de trabajo se ingresan en el sistema ERP de la empresa y sirven para coordinar y gestionar las actividades de mantenimiento o producción.

% \textbf{Tareas}: Actividades individuales dentro de una orden de trabajo. Estas tareas pueden tener requisitos de precedencia, es decir, algunas deben completarse antes de que otras puedan comenzar. Cada tarea cuenta con una fecha de inicio más temprana (earliest date), una fecha requerida de finalización, una duración, una cantidad de trabajadores necesaria y recursos específicos que se requieren para su ejecución.

\textbf{Criticidad}: La criticidad clasifica las tareas según su nivel de prioridad, en una escala del 1 al 3. Las tareas con criticidad 1 son las más urgentes y deben programarse primero, ya que es grave si no se completan dentro de su ventana de tiempo. Las tareas con criticidad 2 y 3 son menos prioritarias y pueden permitirse más flexibilidad en su programación.

% \textbf{Recursos}: Los recursos son los elementos limitados que se necesitan para ejecutar las tareas. En este problema, se identifican dos tipos principales de recursos: \textit{Cuadrillas} y \textit{Equipos auxiliares}.

\textbf{Cuadrilla}: La cuadrilla representa un grupo de trabajo asignado a una tarea específica dentro de la orden de trabajo. Cada cuadrilla tiene un número determinado de trabajadores y sigue un esquema de turnos específico, trabajando un número fijo de horas por día y un determinado número de días a la semana. La cuadrilla es responsable de ejecutar las operaciones asignadas dentro de su turno.

\textbf{Equipos auxiliares}: En este proyecto, los equipos auxiliares se refieren a los recursos que son utilizados por varias cuadrillas y que tienen una disponibilidad limitada. Estos equipos forman parte de los \textit{Production Resource Tools} (PRT) y son críticos en la programación, ya que su uso debe gestionarse cuidadosamente para evitar conflictos y sobreasignaciones. Ejemplos típicos de estos equipos incluyen grúas, camiones pluma, \textit{boom trucks}, \textit{forklifts}, y alza hombres.

\textbf{Turno}: El turno define el esquema de trabajo de una cuadrilla. Por ejemplo, un turno 7x7D implica 7 días de trabajo seguidos por 7 días de descanso. D (día) indica que el turno es diurno, mientras que N (noche) indica que el turno es nocturno.

\textbf{Makespan}: El makespan es el tiempo total de ejecución del proyecto, es decir, la duración total desde el inicio de la primera tarea hasta la finalización de la última.


% \textbf{Planificación}: La planificación es el proceso llevado a cabo por el equipo de planificadores, quienes establecen una ventana de tiempo en la que deben realizarse las tareas de mantenimiento. Este proceso se realiza considerando los requerimientos de las máquinas, los tiempos de los procesos industriales y otros factores relacionados con las operaciones del negocio. Es una etapa inicial que no contempla las restricciones de recursos, sino que establece un marco general para la ejecución de las actividades.

% \textbf{Programación}: La programación es el proceso mediante el cual el equipo de programación toma la planificación inicial y organiza las tareas de manera detallada, asignando recursos específicos y fechas exactas. Durante esta etapa, se balancean los recursos disponibles para evitar sobreasignaciones y garantizar que todas las tareas puedan completarse dentro de sus ventanas de tiempo. La programación precisa y eficiente es clave para minimizar errores y optimizar el uso de los recursos.


%%%%% SECCION 2 %%%%%

\section{Análisis y Descripción del Problema de Programación de Tareas}

Con el objetivo de generalizar el proceso de programación de tareas en el rubro minero, se realizó un estudio que combinó el análisis de los documentos normativos del proceso con una encuesta dirigida al personal encargado de la programación. Este enfoque permitió comprender el funcionamiento operativo actual, identificar las principales barreras y desafíos, y validar la necesidad de una solución automatizada.

A continuación, se presenta una descripción detallada del proceso actual, sus elementos clave y las restricciones involucradas, como punto de partida para el diseño de la solución propuesta.


\subsection{Descripción del Proceso de Programación}

El proceso de programación de tareas en el área de mantenimiento es posterior a la etapa previa de planificación, la cual proporciona los \textit{inputs} esenciales, como las ventanas temporales iniciales para las tareas. A partir de esta información, el equipo de programación adapta las tareas a las restricciones reales de recursos mediante un ciclo semanal iterativo. A continuación, se describen en detalle estas etapas y su interacción.

\subsubsection{Proceso de Planificación}

Previo al proceso de programación, el equipo de planificación es responsable de definir, con base en los requerimientos de las máquinas, los tiempos de los procesos industriales, y otros factores relacionados con el negocio minero, las ventanas temporales en las que deben ejecutarse las tareas de mantenimiento. Esto da como resultado una planificación inicial sobre la cual se basa el proceso de programación.

La planificación considera los objetivos estratégicos de la mina y prioriza el cumplimiento de los requerimientos operativos. Como resultado, se genera una planificación inicial en bruto que indica, para cada tarea, la ventana dentro de la cual debe ser realizada. Sin embargo, este proceso no contempla las restricciones de recursos (personal, equipos o herramientas) y asume la disponibilidad de estos en todo momento. Por lo tanto, es necesario el proceso de programación para asignar los recursos de forma precisa, considerando las limitaciones reales de la operación.

\subsubsection{Proceso de Programación}

El equipo de programación recibe esta planificación inicial como \textit{input} y realiza un trabajo detallado para adaptarla a las capacidades reales de los recursos disponibles. Su labor principal es balancear los recursos, asegurando que no haya sobreasignaciones y que todas las tareas puedan ser ejecutadas dentro de sus respectivas ventanas. Esto incluye:

\begin{itemize}
    \item \textbf{Generar el borrador inicial}: Crear una primera versión del cronograma, integrando las tareas planificadas y asignando recursos preliminares. Este paso suele representar una parte significativa del proceso, dado que establece la base para los ajustes posteriores.
    \item \textbf{Resolver conflictos de recursos}: Identificar y solucionar problemas relacionados con la disponibilidad de recursos, evitando sobreasignaciones y asegurando que cada tarea tenga los recursos necesarios para su ejecución.
    \item \textbf{Validar con otras áreas}: Consultar y coordinar con las áreas relacionadas para garantizar la viabilidad del cronograma, obteniendo el visto bueno sobre la distribución de tareas y recursos.
    \item \textbf{Realizar ajustes finales}: Incorporar cambios de última hora y ajustar los detalles finales del cronograma para garantizar su alineación con las necesidades operativas.
\end{itemize}

\begin{figure}[htbp]
    \centering
    \frame{\includegraphics[width=0.75\textwidth]{imgs/process_flowchart.png}}
    \caption{Flujo de Proceso de Programación de Actividades.}
    \label{fig:flowchart}
\end{figure}


El cronograma resultante detalla las tareas a realizar, la fecha y hora de inicio, la duración y los recursos necesarios. Este proceso también considera tareas en función de su criticidad, priorizando aquellas que tienen mayor impacto en la continuidad operativa.

\subsubsection{Ciclo Semanal de Programación}

El proceso de programación en el área de mantenimiento se organiza en un ciclo semanal, cuyo objetivo es garantizar que el cronograma sea factible, actualizado y aprobado por las áreas involucradas, alineándose con los requerimientos del negocio y la disponibilidad de recursos.

Cada miércoles, el equipo de programación toma como base el cronograma generado en el ciclo de la semana anterior, que ya contiene actividades programadas para la semana actual. Este cronograma inicial es revisado y ajustado, incorporando nuevas tareas provenientes del proceso de planificación y actualizando la disponibilidad de recursos. Con esta información, se genera el borrador del cronograma que abarca las próximas tres semanas.

El borrador se valida en conjunto con otras áreas para resolver conflictos de recursos y ajustar prioridades. Finalmente, cada viernes se emite el cronograma oficial, que servirá de base para el próximo ciclo. Este enfoque iterativo asegura que la programación sea dinámica y adaptable, optimizando la continuidad operativa.


\subsection{Diagnóstico del proceso actual}

Como parte del levantamiento de información para comprender el estado actual del proceso de programación de tareas de mantenimiento, se realizó una encuesta dirigida al personal de programación de la empresa colaboradora. Los resultados permiten identificar aspectos críticos y validar la necesidad de herramientas automatizadas que optimicen la generación de cronogramas. Para ver el detalle de los resultados de la encuesta se puede consultar el Anexo \ref{anexo:encuesta}.

A continuación, se presentan los principales hallazgos y conclusiones derivados del diagnóstico del proceso actual:

\begin{itemize}
    \item \textbf{Alta dedicación horaria}: 64\% de los encuestados invierte más de la mitad de su jornada semanal en generación del cronograma de actividades.
    \item \textbf{La creación del borrador inicial} es la fase más intensiva en tiempo, superando otras actividades como resolver conflictos o validar con otras áreas.
    \item \textbf{La no disponibilidad de materiales y repuestos} durante la ejecución de las mantenciones es el error más recurrente.
    \item \textbf{Entorno altamente dinámico}: El 90\% de los encuestados enfrenta cambios de último minuto al menos una vez por semana.
    \item \textbf{Problemas de coordinación con otras áreas} y \textbf{falta de colaboración} son barreras adicionales que dificultan la programación eficiente.
\end{itemize}

Los resultados refuerzan la hipótesis de que el proceso de programación podría beneficiarse significativamente de herramientas que automatizan partes clave del flujo de trabajo. En particular, una solución que automatice la creación del borrador inicial del cronograma y que permita incorporar cambios de último minuto sería altamente valorada. Se estima que una herramienta con estas capacidades podría reducir hasta en un 50\% el tiempo dedicado por los equipos de programación a estas tareas, liberando tiempo para actividades de mayor valor estratégico.

\begin{figure}[htbp]
    \centering
    \frame{\includegraphics[scale=0.6]{imgs/pie_chart.png}}
    \captionsetup{justification=centering} % Para centrar el texto de la leyenda
    \caption{Distribución del tiempo de programación \\ \textbf{Fuente}: Elaboración propia en base a encuesta (Anexo \ref{anexo:encuesta})}
    \label{fig:pie_chart}
  \end{figure}

\section{Definiciones teóricas}
En este apartado se presentan las definiciones y conceptos teóricos fundamentales para comprender el enfoque del proyecto. Se abordan el RCPSP y los algoritmos CP. Estos conceptos son esenciales para entender las metodologías utilizadas en nuestra optimización de la programación de actividades de mantenimiento.

\subsection{Problema de Programación de Proyectos con Restricciones de Recursos (RCPSP)}
El RCPSP es un problema clásico en el campo de la investigación operativa y la gestión de proyectos. Cabe dentro de los \textit{Constraint Satisfaction Problems} (CSP) y mas especificamente dentro de los \textit{Constraint Optimization Problems} (COP).

Consiste en programar un conjunto de actividades interrelacionadas, considerando restricciones tanto de precedencia entre tareas como de disponibilidad limitada de recursos. El objetivo principal es determinar el calendario óptimo que minimice la duración total del proyecto (\textit{makespan}) o que optimice otro criterio relevante, como costos o utilización de recursos\cite{artigues2008resource}.
    

Las principales características del RCPSP incluyen:
\begin{itemize}
  \item \textbf{Restricciones de precedencia}: Algunas actividades no pueden comenzar hasta que otras hayan finalizado
  \item \textbf{Recursos limitados}: Los recursos necesarios para realizar las actividades (como mano de obra, equipos o materiales) tienen una disponibilidad limitada en cada periodo de tiempo.
  \item \textbf{Objetivo de optimización}: Generalmente, se busca minimizar el tiempo total del proyecto, aunque pueden considerarse otros objetivos como minimizar costos o equilibrar la carga de recursos.
\end{itemize}

En la Figura \ref{fig:rcpsp} se muestra un ejemplo de un RCPSP con 2 recursos y 10 tareas. En él se muestra que el Recurso A tiene una capacidad de 7 unidades mientras que el Recurso B tiene una capacidad de 4 unidades. Dadas los requerimientos de recursos de cada tarea y las capacidades de cada recurso, en la figura se muestra una solución que logra un \textit{makespan} de 12 unidades de tiempo.

\begin{figure}[htbp]
    \centering
    \frame{\includegraphics[width=0.5\textwidth]{imgs/rcpsp.png}}
    \caption{Ejemplo de un RCPSP con 2 recursos y 10 tareas.}
    \label{fig:rcpsp}
\end{figure}
    

El RCPSP es reconocido como un problema NP-Hard, lo que significa que no se dispone de un algoritmo que pueda resolver todas sus instancias en tiempo polinomial, dada la complejidad inherente al crecimiento exponencial del espacio de soluciones conforme aumenta el número de tareas y recursos involucrados.

Si bien para instancias reducidas pueden aplicarse métodos exactos, la escalabilidad del problema suele requerir el uso de enfoques alternativos. En este sentido, CP resulta una herramienta especialmente eficaz, ya que permite modelar y resolver el RCPSP de forma declarativa, aprovechando técnicas de propagación de restricciones y búsqueda guiada.



\subsection{Algoritmos de Programación por Restricciones}

La Programación por Restricciones (CP, por sus siglas en inglés) es una técnica ampliamente utilizada para resolver problemas combinatorios complejos, como los problemas de programación y planificación de actividades. En el contexto de este trabajo, CP es fundamental para abordar el RCPSP, proporcionando un marco eficaz para modelar y resolver problemas que incluyen restricciones de tiempo y recursos.

Un problema de satisfacción de restricciones (\textit{Constraint Satisfaction Problem}, CSP) se define como un conjunto de variables  $V$ , cada una asociada a un dominio de valores posibles  $D$ , y un conjunto de restricciones  $R$  que especifican las combinaciones válidas de valores entre las variables. La solución a un CSP es una asignación de valores a las variables que satisface todas las restricciones. Cuando se incorpora una función objetivo  $O$  para optimizar, el problema se denomina \textit{Constraint Optimization Problem} (COP)\cite{rossi2006}.

\begin{figure}[htbp]
\centering
\frame{\includegraphics[width=0.75\textwidth]{imgs/constraint_programming.png}}
\caption{Esquema de Programación con Restricciones.}
\label{fig:constraint_programming}
\end{figure}

En el contexto del RCPSP, CP permite representar las actividades mediante variables de inicio, duración y fin. Las restricciones temporales, como las de precedencia, aseguran que el orden de ejecución sea respetado, mientras que las restricciones de recursos garantizan que no se exceda la capacidad disponible en ningún momento. Además, las ventanas temporales asociadas a cada tarea reflejan los plazos operativos.

La función objetivo de este tipo de problemas puede variar, siendo común la minimización del \textit{makespan}. CP permite, además, modelar estos problemas de manera declarativa, separando la especificación del modelo de los algoritmos utilizados para resolverlo. Esto facilita la extensión y modificación de los modelos, adaptándolos a las necesidades específicas sin comprometer la eficacia de los métodos de solución.


% \subsection{Algoritmos de Programación por Restricciones}
% Los algoritmos de Programación por Restricciones son técnicas avanzadas de optimización que se utilizan para resolver problemas combinatorios complejos, como el Problema de Programación de Proyectos con Restricciones de Recursos (RCPSP). Estos algoritmos son especialmente efectivos debido a su capacidad para manejar de manera eficiente restricciones lógicas, aritméticas y de recursos.

% La Programación por Restricciones es un paradigma en el que se definen variables, dominios y restricciones. Las variables representan los elementos desconocidos del problema, los dominios especifican los posibles valores que pueden tomar, y las restricciones limitan las combinaciones de valores que las variables pueden asumir simultáneamente. El objetivo es encontrar asignaciones de valores a las variables que satisfagan todas las restricciones impuestas. Este enfoque es especialmente útil cuando las restricciones son numerosas y complejas, permitiendo modelar problemas de manera flexible y detallada.

% En el contexto del RCPSP, los algoritmos de Programación por Restricciones ofrecen un marco poderoso para modelar y resolver el problema de manera eficiente. Se definen variables de inicio y fin para cada tarea, así como variables de intervalo que combinan inicio, duración y fin, facilitando el manejo de restricciones temporales y de recursos. Las restricciones de precedencia se establecen para asegurar que una tarea no pueda comenzar hasta que sus tareas precedentes hayan finalizado, lo cual se expresa mediante relaciones de desigualdad entre las variables de fin e inicio de las tareas involucradas.

% Las restricciones de recursos se manejan mediante la restricción cumulativa, que garantiza que, en cualquier momento, la suma de los recursos consumidos por las tareas en ejecución no exceda la capacidad disponible. Esto es crucial en problemas donde los recursos son limitados y deben ser compartidos entre múltiples tareas. Además, se consideran las ventanas de tiempo para las tareas, imponiendo límites en las variables de inicio y fin según las fechas de inicio más tempranas y las fechas límite, lo que refleja la disponibilidad y los plazos específicos de cada tarea.

% La función objetivo en estos problemas suele ser minimizar el makespan, es decir, el tiempo total del proyecto. Los algoritmos de Programación por Restricciones permiten integrar esta función objetivo en el modelo, buscando no solo soluciones factibles que satisfagan todas las restricciones, sino también optimizar este criterio para mejorar la eficiencia global del proyecto.

% Una de las ventajas clave de los algoritmos de Programación por Restricciones es su eficiencia en el manejo de restricciones complejas, permitiendo resolver problemas NP-Hard como el RCPSP en tiempos razonables. Su flexibilidad permite incorporar fácilmente nuevas restricciones o modificar las existentes sin reestructurar todo el modelo, lo que es especialmente útil en entornos dinámicos donde las condiciones pueden cambiar. Además, son capaces de encontrar soluciones de alta calidad, óptimas o cercanas al óptimo, lo cual es esencial en contextos industriales donde la optimización de recursos y tiempos es crítica.


\section{Aplicación de los conceptos teóricos al problema}


Con el objetivo de automatizar el proceso de programación de tareas, se llevó a cabo una revisión de los documentos de procedimientos utilizados en la empresa además de entrevistas a personal clave. Este análisis permitió comprender en detalle cómo funciona la programación de tareas en el contexto operativo, y por qué resulta esencial generalizar dicho proceso en un modelo matemático o computacional. Esta generalización es clave, ya que proporciona la base necesaria para desarrollar una herramienta que permita automatizar el problema de programación de tareas de manera eficaz y eficiente.

\subsection{Datos necesarios para el proceso de programación}  

El proceso de programación requiere como \textit{input} el resultado del proceso de planificación, que define los parámetros esenciales para cada tarea. Esta información incluye una descripción general de la tarea, indicando a qué orden de trabajo corresponde, además de datos sobre la ventana de fechas en la que debe ejecutarse. También se especifica la duración de la tarea, su nivel de criticidad y los recursos necesarios para ejecutarla, como cuadrillas y equipos. El detalle de una tarea estándar con toda esta información se puede consultar en el Cuadro \ref{table:task}.  

Además de la información proveniente del proceso de planificación, es necesario extraer datos adicionales desde el sistema ERP de la empresa. Esto incluye la disponibilidad de las cuadrillas, la cual se determina a partir de los esquemas de turnos que definen las ventanas de tiempo en las que estas pueden trabajar. También es fundamental considerar los equipos auxiliares, cuya disponibilidad debe gestionarse cuidadosamente, ya que estos pueden ser utilizados por diferentes cuadrillas en momentos distintos.  

La integración de estos datos asegura que el proceso de programación tenga toda la información necesaria para asignar las tareas de manera eficiente, respetando las restricciones operativas y de recursos disponibles.  


\begin{table}[htbp]
    \centering
    \captionsetup{justification=centering}
    \vspace{0.5cm}
    \begin{tabular}{p{6cm} p{8cm}}
        \toprule
        \textbf{Atributo} & \textbf{Descripción} \\
        \midrule
        \textbf{ID Orden de Trabajo} & 4000001 \\
        \textbf{ID Tarea} & 001 \\
        \textbf{Descripción OT} & Cambio de suspensión trasera lado izquierdo \\
        \textbf{Descripción Tarea} & Retiro de suspensión trasera \\
        \textbf{Fecha Inicio Extrema} & 2024-11-29 \\
        \textbf{Fecha Requerida} & 2024-12-30 \\
        \textbf{Cuadrilla} & BM001 \\
        \textbf{Equipo Auxiliar} & Alza Hombres Telescópico \\
        \textbf{Duración (horas)} & 6 \\
        \textbf{Impacto} & 2 \\
        \textbf{Cantidad de Trabajadores} & 4 \\
        \bottomrule
    \end{tabular}
    \caption{Ejemplo de Tarea y sus atributos.}
    \label{table:task}
\end{table}


\subsection{Consideraciones al programar}
El proceso de programación de actividades de mantenimiento implica que el programador tome las órdenes de trabajo pendientes y agende cada una de las tareas considerando su compatibilidad con los horarios y restricciones de otras actividades y de los recursos. Se deben tener en cuenta las siguientes consideraciones

\begin{itemize}
    \item Cada \textbf{tarea} viene acompañada de información esencial, asignada en el proceso de planificación. Dentro de esta información tenemos la fecha de inicio extrema, la fecha requerida, la duracion, los recursos requeridos y la criticidad.
    
    \item Cada \textbf{cuadrilla} tiene su propio esquema de turnos, lo que implica que hay ventanas de tiempo en las cuales estos recursos no están diponibles.
    
    \item Cada \textbf{cuadrilla} tiene una capacidad determinada, que corresponde al número de trabajadores disponibles, lo que influye en la cantidad de tareas que pueden realizarse simultáneamente. Por ejemplo, si una cuadrilla tiene una capacidad de 10 trabajadores, podrá ejecutar 5 tareas que requieran 2 trabajadores cada una de manera simultánea.
    
    \item Los \textbf{equipos auxiliares} son unitarios, por lo tanto no pueden asignarse a mas de una tareas simultaneamente.
\end{itemize}


\subsection{Generalización del Problema como RCPSP}

Vamos a modelar el problema de programación de tareas como un problema de optimización con restricciones, específicamente como una versión del RCPSP. El objetivo es asignar tiempos de inicio a las tareas, maximizando la prioridad de las tareas programadas según su impacto, y respetando las restricciones de capacidad de los recursos, las ventanas de tiempo, los intervalos prohibidos y las posibles relaciones de precedencia entre tareas.

A continuación, se presenta una descripción general del modelo de programación de tareas con recursos limitados que servirá como base para la implementación de la solución.

\subsubsection{Parámetros del Modelo}

Tenemos los siguientes elementos:

\textbf{Tareas}: Un conjunto \( T = \{T_0, T_1, \dots, T_n\} \), donde cada tarea \( T_i \) tiene:
  \begin{itemize}
    \item Una duración \( C(T_i) \in \mathbb{N} \).
    \item Un conjunto de recursos requeridos \( D(T_i) \subseteq R \).
    \item Una cantidad de recurso requerido \( q_i \in \mathbb{N} \).
    \item Un impacto \( \text{Impact}_i \in \mathbb{N} \), donde un valor más bajo indica mayor prioridad.
    \item Una ventana de tiempo \( W(T_i) = [\text{early}_i, \text{late}_i] \), que indica el tiempo más temprano y más tardío en el que puede comenzar la tarea.
  \end{itemize}

\textbf{Recursos}: Un conjunto \( R = \{R_0, R_1, \dots, R_m\} \), donde cada recurso \( R_j \) tiene:
  \begin{itemize}
    \item Una capacidad \( P(R_j) \in \mathbb{N} \).
    \item Un tipo \( \text{Tipo}(R_j) \in \{0, 1\} \). Donde 0 indica que el recurso es una cuadrilla y 1 indica que es un equipo compartido. 
    \item Un conjunto de intervalos prohibidos \( I(R_j) = \{[a_1, b_1), [a_2, b_2), \dots\} \), durante los cuales el recurso no está disponible.
  \end{itemize}

\textbf{Grupos de tareas}: Un conjunto \( G = \{G_0, G_1, \dots\} \), donde cada grupo \( G_k \subseteq T \) tiene restricciones de precedencia entre las tareas que lo componen.

\vspace{0.5cm}

\begin{tcolorbox}[colback=gray!5!white, colframe=gray!75!black, title={Parámetros del modelo}]
    \begin{itemize}
        \item \( T = \{T_0, T_1, \dots, T_n\} \): conjunto de \textbf{tareas}.
        \item \( R = \{R_0, R_1, \dots, R_m\} \): conjunto de \textbf{recursos}.
        \item \( C(T_i) \in \mathbb{N} \): \textbf{duración} de la tarea \( T_i \).
        \item \( D(T_i) \subseteq R \): \textbf{recursos requeridos} por la tarea \( T_i \).
        \item \( q_i \in \mathbb{N} \): \textbf{cantidad} de recurso que requiere la tarea \( T_i \).
        \item \( \text{Impact}_i \in \mathbb{N} \): \textbf{impacto} de la tarea \( T_i \) (prioridad inversa).
        \item \( W(T_i) = [\text{early}_i, \text{late}_i] \): \textbf{ventana de tiempo} para la tarea \( T_i \).
        \item \( P(R_j) \in \mathbb{N} \): \textbf{capacidad} del recurso \( R_j \).
        \item \( \text{Tipo}(R_j) \in \{0, 1\} \): \textbf{tipo} del recurso \( R_j \).
        \item \( I(R_j) = \{[a_k, b_k)\} \): \textbf{intervalos prohibidos} del recurso \( R_j \).
        \item \( G = \{G_0, G_1, \dots\} \): conjunto de \textbf{grupos de tareas} con restricciones de precedencia.
    \end{itemize}
\end{tcolorbox}

\vspace{0.5cm}

\subsubsection{Variables de decisión}

Para modelar el problema, introducimos las siguientes variables de decisión:

\begin{itemize}
    \item \( x_i \in \{0, 1\} \): Indica si la tarea \( T_i \) es \textbf{programada} (\( x_i = 1 \)) o no (\( x_i = 0 \)).
    \item \( S_i \in \mathbb{N} \): Tiempo de \textbf{inicio} de la tarea \( T_i \), sujeto a \( \text{early}_i \leq S_i \leq \text{late}_i - C(T_i) \) si \( x_i = 1 \).
    \item \( E_i = S_i + C(T_i) \): Tiempo de \textbf{finalización} de la tarea \( T_i \).
    \item \( \text{Intervalo}(T_i) = [S_i, E_i) \): Intervalo de ejecución de la tarea \( T_i \).
    \item \( y_k \in \{0, 1\} \): Indica si el \textbf{grupo de tareas} \( G_k \) es programado (\( y_k = 1 \)) o no (\( y_k = 0 \)).
\end{itemize}

\vspace{0.5cm}

\begin{tcolorbox}[colback=gray!5!white, colframe=gray!75!black, title={Variables de decisión}]
    \begin{itemize}
        \item \( x_i \in \{0, 1\} \): Variable binaria que indica si la tarea \( T_i \) es \textbf{programada}.
        \item \( S_i \in \mathbb{N} \): Tiempo de \textbf{inicio} de la tarea \( T_i \).
        \item \( E_i = S_i + C(T_i) \): Tiempo de \textbf{finalización} de la tarea \( T_i \).
        \item \( \text{Intervalo}(T_i) = [S_i, E_i) \): Intervalo de ejecución de la tarea \( T_i \).
        \item \( y_k \in \{0, 1\} \): Variable binaria que indica si el grupo \( G_k \) es \textbf{programado}.
    \end{itemize}
\end{tcolorbox}

\vspace{0.5cm}

\subsubsection{Restricciones}

El modelo considera las siguientes 5 restricciones:

\textbf{a. Ventanas de tiempo}:

Cada tarea debe comenzar y finalizar dentro de su ventana de tiempo permitida si es programada:

\[
x_i = 1 \implies \text{early}_i \leq S_i \leq \text{late}_i - C(T_i)
\]

\textbf{b. Restricciones de capacidad de los recursos}:

Para cada recurso \( R_j \), la suma de las demandas de las tareas que requieren el recurso en cualquier momento no debe exceder su capacidad:

\[
\sum_{\substack{T_i \in T \\ R_j \in D(T_i)}} q_i \cdot \delta_{ij}(t) \leq P(R_j), \quad \forall t \in \text{Horizonte}
\]

Donde \( \delta_{ij}(t) = 1 \) si \( t \in [S_i, E_i) \) y \( x_i = 1 \); en caso contrario, \( \delta_{ij}(t) = 0 \).

El tipo de recurso afecta cómo se calcula la demanda:

\begin{itemize}
    \item Si \( \text{Tipo}(R_j) = 0 \), se utiliza \( q_i \) como demanda.
    \item Si \( \text{Tipo}(R_j) = 1 \), cada tarea consume una unidad de capacidad (\( q_i = 1 \)).
\end{itemize}

\textbf{c. Intervalos prohibidos de los recursos}:

Las tareas no pueden ser programadas durante los intervalos prohibidos de los recursos que requieren:

\[
x_i = 1 \implies \forall R_j \in D(T_i), \forall [a_k, b_k) \in I(R_j): \quad [S_i, E_i) \cap [a_k, b_k) = \emptyset
\]

\textbf{d. Restricciones de precedencia en grupos de tareas}:

Para cada grupo \( G_k \), si el grupo es programado, las tareas deben seguir una secuencia específica:

\[
y_k = 1 \implies \forall T_i, T_{i+1} \in G_k: S_{i+1} \geq E_i
\]

Además, las tareas dentro de un grupo se programan juntas o no se programan:

\[
\forall T_i \in G_k: x_i = y_k
\]

\textbf{e. Consistencia de variables}:

Si una tarea no es programada, sus variables de tiempo no tienen relevancia y pueden ser fijadas a cero para simplificar el modelo:

\[
x_i = 0 \implies S_i = 0, \quad E_i = 0
\]

\vspace{0.5cm}

\subsubsection{Objetivo}

El objetivo es minimizar una combinación del makespan global y la penalización asociada a no programar tareas de mayor prioridad. Para esto, se define una función de peso para cada tarea basada en su impacto:

\[
w_i = (\text{Impact}_{\text{max}} + 1 - \text{Impact}_i)^3
\]

Donde \( \text{Impact}_{\text{max}} \) es el valor máximo de impacto entre todas las tareas.

La función objetivo es:

\[
\text{Minimizar } Z = \alpha \cdot \text{makespan} + \beta \cdot \sum_{i=0}^{n} w_i \cdot (1 - x_i)
\]

Donde:

\begin{itemize}
    \item \( \alpha \): Peso asociado al makespan global.
    \item \( \beta \): Peso asociado a la penalización por no programar tareas según su impacto.
\end{itemize}

Este enfoque busca una solución que equilibre la minimización del makespan global y la priorización de tareas críticas según su impacto.

\vspace{0.5cm}

\subsubsection{Resumen del Modelo}

El modelo presentado integra múltiples aspectos del problema de programación de tareas con recursos limitados:

\begin{itemize}
    \item \textbf{Ventanas de tiempo}: Asegura que las tareas se programen dentro de los intervalos permitidos.
    \item \textbf{Capacidad de recursos}: Garantiza que la demanda no exceda la capacidad disponible en ningún momento.
    \item \textbf{Intervalos prohibidos}: Evita la asignación de tareas durante periodos en los que los recursos no están disponibles.
    \item \textbf{Precedencia en grupos}: Mantiene el orden requerido entre tareas relacionadas.
    \item \textbf{Optimización basada en impacto}: Prioriza la programación de tareas más críticas según su impacto.
    \item \textbf{Minimización del makespan}: Incluye la minimización del makespan global.
\end{itemize}



\subsection{Detalle de Función Objetivo}

Dado que en la práctica puede surgir la posibilidad de que ciertas tareas no puedan ser programadas debido a restricciones como la indisponibilidad de recursos, ventanas de tiempo incompatibles o conflictos en los intervalos prohibidos, es crucial considerar un mecanismo que penalice esta situación, de otro modo cada vez que hayan este tipo de incompatibilidades, el modelo no podrá encontrar una solución factible. Por ello, la función objetivo incluye un componente que penaliza la no programación de tareas. Esto convierte en factibles aquellas soluciones que no logran programar todas las tareas, pero minimiza esta situación tanto como sea posible.

Por otro lado, para equilibrar este aspecto con el objetivo de eficiencia general, también se incluye un segundo componente que penaliza la extensión total del tiempo necesario para completar todas las tareas programadas (makespan). Este enfoque asegura que el modelo busque simultáneamente programar tantas tareas como sea posible y minimizar el tiempo total requerido para su ejecución.

La función objetivo combina estos dos componentes mediante parámetros de ponderación \( \alpha \) y \( \beta \), que permiten ajustar la importancia relativa de cada criterio en la optimización:

\[
\text{Minimizar } Z = \alpha \cdot \text{makespan} + \beta \cdot \sum_{i=0}^{n} w_i \cdot (1 - x_i)
\]

Donde:

\begin{enumerate}
    \item \textbf{Componente del Makespan (\( \alpha \cdot \text{makespan} \))}: Busca reducir la extensión global del horizonte temporal necesario para completar todas las tareas programadas, incentivando la eficiencia en el uso de recursos y tiempo.

    \item \textbf{Componente de Penalización por Tareas no Programadas (\( \beta \cdot \sum_{i=0}^{n} w_i \cdot (1 - x_i) \))}: Penaliza la no programación de tareas, asignando un peso mayor a aquellas con un impacto crítico. Aquí, \( w_i \) es el peso asociado a la tarea \( T_i \), definido como:
    \[
    w_i = (\text{Impact}_{\text{max}} + 1 - \text{Impact}_i)^3
    \]
    Este peso aumenta de manera cúbica con la criticidad (bajo valor de \( \text{Impact}_i \)) de la tarea, priorizando explícitamente las tareas más importantes.
\end{enumerate}

\subsubsection*{Razonamiento detrás de la Ponderación}

El uso de \( \alpha \) y \( \beta \) permite al modelo adaptarse a diferentes prioridades operativas. Por ejemplo:

\begin{itemize}
    \item Si \( \alpha \) es significativamente mayor que \( \beta \), el modelo favorecerá soluciones con makespan reducido, aun si algunas tareas críticas no se programan.
    \item Si \( \beta \) domina sobre \( \alpha \), el enfoque se orientará a maximizar la programación de tareas críticas, incluso si eso resulta en un makespan mayor.
\end{itemize}

De esta manera, la función objetivo ofrece un balance flexible que puede ser ajustado según las necesidades específicas del problema, garantizando una solución óptima que considere tanto la completitud de las tareas como la eficiencia global.


%%%%%%%%%%%%%%%%%%%

\section{Flujo de Trabajo de la Solución}

El flujo de trabajo de la solución se ha reorganizado en cuatro etapas secuenciales, cada una diseñada para estructurar y procesar la información de programación de manera eficiente. Estas etapas abarcan desde la ingesta y preparación de datos hasta la generación de un cronograma optimizado, maximizando la eficiencia computacional del solver. A continuación, se describen las cuatro partes que componen el flujo de trabajo:

\begin{enumerate}
    \item \textbf{Pre-Procesamiento}: Se toman los datos de las tareas desde distintas fuentes (ERP, Microsoft Project, u otros formatos) y se estandarizan, asegurando que los campos relevantes estén estructurados de manera uniforme.

    \item \textbf{Segmentación en Subconjuntos}: Para mejorar la eficiencia del solver, las tareas se agrupan en subconjuntos relacionados. Este proceso identifica conexiones entre tareas mediante relaciones compartidas, como recursos comunes o dependencias temporales. La segmentación permite particionar el problema en componentes más manejables, reduciendo la complejidad computacional.

    \item \textbf{Solver}: Se utiliza el modelo de CP de \textit{OR-Tools} para resolver cada subconjunto de manera independiente, aplicando restricciones y maximizando el cumplimiento de tareas según su prioridad.

    \item \textbf{Post-Procesamiento}: Los resultados obtenidos del solver se consolidan y procesan para generar un cronograma unificado. Finalmente, se crean archivos compatibles con herramientas como Microsoft Project, facilitando su integración en los flujos de trabajo.
\end{enumerate}

Este flujo de trabajo modular garantiza flexibilidad y adaptabilidad, permitiendo procesar datos de diversas fuentes, optimizar la programación bajo restricciones complejas y generar resultados en formatos útiles para los usuarios finales. A continuación, se describen en detalle cada una de las etapas mencionadas.


A continuación se presentan las subsecciones adaptadas a la nueva organización propuesta. Ahora el flujo de trabajo se compone de cuatro etapas principales: Pre-Procesamiento, Segmentación en Subconjuntos, Solver y Post-Procesamiento. Las secciones originales de \textit{Input} y \textit{Output} se han integrado en las etapas inicial y final, respectivamente, para reflejar la nueva estructura modular.


\begin{figure}[htbp]
    \centering
    \frame{\includegraphics[width=.9\textwidth]{imgs/solution.png}}
    \caption{Flujo de Trabajo de la Solución.}
    \label{fig:solution}
\end{figure}

\subsection{Pre-Procesamiento}

La etapa de Pre-Procesamiento constituye el punto de partida del flujo de trabajo, recibiendo y preparando la información procedente de diversas fuentes (como sistemas ERP, Microsoft Project u otros formatos externos). Esta fase garantiza que los datos sobre tareas, personal y equipos estén libres de inconsistencias, limpios y normalizados, facilitando así la labor posterior del solver.

Las operaciones clave realizadas durante el Pre-Procesamiento incluyen:

\begin{itemize}
    \item \textbf{Corrección de discrepancias}: Se revisan y ajustan datos en caso de encontrar inconsistencias. Por ejemplo, si una tarea presenta una fecha límite previa a su fecha de inicio permitida, se corrige automáticamente. Asimismo, se unifican los formatos de fechas, duraciones y demás campos relevantes.

    \item \textbf{Cuantización de ventanas horarias}: Las duraciones se expresan en intervalos de 15 minutos para trabajar con unidades enteras en el solver. De este modo, una tarea de una hora se representa como 4 unidades, y una tarea de 15 minutos como 1 unidad, optimizando la eficiencia en el modelado de restricciones temporales.

    \item \textbf{Estandarización en un formato unificado (JSON)}: Tras la limpieza y normalización, la información se organiza en un archivo JSON. Este archivo consolida datos sobre duración de las tareas, recursos requeridos, ventanas temporales y dependencias, garantizando un formato coherente que servirá de base para las etapas posteriores.

\end{itemize}

Una vez generado el archivo JSON estandarizado, se crean las estructuras de datos internas necesarias para el solver. A partir de dicho JSON, se construyen diccionarios que representarán las tareas y sus atributos relevantes:

\begin{itemize}
    \item \textbf{Diccionario de tareas}: Contiene la duración, recursos y herramientas requeridas por cada tarea, junto con las variables clave del modelo (inicio, fin, entre otros).

    \item \textbf{Diccionario de ventanas de tiempo}: Especifica para cada tarea sus límites temporales (inicios tempranos, finales máximos), a fin de asegurar el cumplimiento de las restricciones temporales definidas.

    \item \textbf{Diccionario de capacidades de recursos}: Detalla la disponibilidad máxima de cada recurso, garantizando que no se sobrepase su límite durante la programación.

    \item \textbf{Diccionario de agrupaciones de tareas}: Define conjuntos de tareas que comparten recursos o secuencias de precedencia, facilitando la coherencia en la programación de actividades relacionadas.

    \item \textbf{Diccionario de intervalos prohibidos}: Registra los periodos en los que ciertos recursos no están disponibles, asegurando que no se asignen tareas en dichos intervalos.

\end{itemize}

En conjunto, el Pre-Procesamiento sienta las bases para las etapas siguientes, generando un entorno de datos consistente y listo para ser segmentado y optimizado.


\subsection{Segmentación en Subconjuntos}

La Segmentación en Subconjuntos tiene como objetivo reducir la complejidad del problema, dividiendo el conjunto global de tareas en grupos más pequeños y manejables. Este proceso se basa en la identificación de dependencias entre tareas, recursos y cuadrillas, garantizando que aquellas actividades que comparten recursos o presentan relaciones críticas se mantengan dentro de un mismo subconjunto.

El método para llevar a cabo esta segmentación es el siguiente:

\begin{enumerate}[label=\alph*.]
    \item \textbf{Construcción del grafo}: Se modelan tareas, cuadrillas y equipos como nodos de un grafo no dirigido, añadiendo aristas entre estos nodos cuando comparten recursos o dependen unos de otros.
    
    \item \textbf{Identificación de componentes conexas}: A través de algoritmos de componentes conexas, se detectan grupos de nodos interrelacionados. Cada componente conexa representa un subconjunto de tareas que deben mantenerse juntas para preservar la coherencia en el uso de recursos y las dependencias.

    \item \textbf{Formación de subconjuntos}: Cada componente conexa determina un subconjunto de tareas que se tratará de manera independiente en el solver. Esto permite abordar el problema en etapas más pequeñas, reduciendo el número de variables y restricciones manejadas de forma simultánea.
\end{enumerate}


\begin{figure}[htbp]
    \centering
    \frame{\includegraphics[width=0.5\textwidth]{imgs/segmentacion.png}}
    \caption{Ejemplo de segmentación a través de componentes conexas.}
    \label{fig:segmentacion}
\end{figure}


Gracias a este enfoque, la complejidad computacional disminuye, se mantiene la coherencia en el uso compartido de recursos y es posible resolver cada subconjunto en paralelo, optimizando el uso de recursos computacionales y disminuyendo el tiempo total de cálculo.


\subsection{Solver}

La tercera etapa del flujo de trabajo consiste en resolver cada uno de los subconjuntos de tareas utilizando el solver de Programación por Restricciones proporcionado por la librería \textit{OR-Tools} de Google. Esta herramienta permite modelar problemas complejos de programación con restricciones, aprovechando las estructuras de datos preparadas en el Pre-Procesamiento.

Para mejorar el desempeño, se aplican estrategias de paralelización con librerías como \texttt{joblib}, ejecutando la resolución de múltiples subconjuntos de forma simultánea en diferentes hilos o núcleos de procesamiento.

Las restricciones se modelan de la siguiente manera:

\begin{itemize}
    \item \textbf{Ventanas de tiempo}: Cada tarea se programa respetando sus límites temporales, utilizando variables de intervalo que delimitan su inicio y fin dentro de los intervalos permitidos.
    
    \item \textbf{Intervalos prohibidos}: Las tareas que requieren ciertos recursos se ajustan para no solaparse con periodos en los que dichos recursos no están disponibles, garantizando la factibilidad de la asignación.

    \item \textbf{Restricciones cumulativas de recursos}: Cada recurso tiene una capacidad máxima. El modelo asegura que el conjunto de tareas asignadas simultáneamente a un mismo recurso no exceda esta capacidad.

    \item \textbf{Precedencia en grupos de tareas}: Cuando existe una secuencia lógica de ejecución entre tareas (por ejemplo, en órdenes de trabajo), se incorporan restricciones de precedencia que aseguran el cumplimiento de dichas relaciones.

\end{itemize}

Para equilibrar la calidad de la solución y el tiempo de cómputo, se emplean parámetros como \texttt{max\_time\_in\_seconds} y \texttt{relative\_gap\_limit}, que limitan el tiempo de búsqueda y la desviación aceptable respecto al óptimo teórico, respectivamente.


\subsection{Post-Procesamiento}

La fase de Post-Procesamiento consolida los resultados generados por el solver y los prepara en formatos finales útiles para su análisis, integración o visualización en herramientas externas.

Partiendo del archivo JSON producido por el solver (que indica para cada tarea si fue programada y su hora de inicio), se procesan estos datos junto con la información original, produciendo:

\begin{itemize}
    \item \textbf{Archivos XML para Microsoft Project}: Se genera un archivo compatible con Microsoft Project, conteniendo horas de inicio, finalización y duraciones, facilitando la incorporación del cronograma en flujos de trabajo existentes.

    \item \textbf{Archivo XLSX para Excel}: Se produce una carta Gantt en Excel, organizando las tareas en un cronograma visual y detallando inicio, fin, duración, así como los recursos asignados, permitiendo una interpretación rápida y clara.

    \item \textbf{Integraciones con APIs empresariales}: Si la organización cuenta con sistemas ERP u otros entornos de gestión, los resultados pueden integrarse automáticamente mediante APIs, asegurando la continuidad operativa y minimizando el trabajo manual.
\end{itemize}

El Post-Procesamiento garantiza que los resultados generados por el solver sean comunicados de forma clara y estén listos para su explotación por usuarios finales, herramientas de gestión o análisis posterior. De este modo, el flujo de trabajo se completa con un producto final útil y adaptable a las necesidades específicas de la organización.

\section{Resultados y Análisis}

El desarrollo e implementación del modelo de optimización ha generado resultados prometedores, tanto en términos de la calidad del cronograma producido como en los beneficios operativos proyectados para el equipo de programación. A continuación, se presentan estadísticas clave y una evaluación de los ahorros potenciales derivados del uso de esta herramienta.


\subsection{Descripción del Dataset}

El dataset utilizado en este proyecto fue proporcionado por el equipo de programación de la empresa colaboradora. Estos datos corresponden a tareas reales de mantenimiento para un período específico de tiempo y reflejan el contexto operativo y las restricciones enfrentadas por la empresa durante dicho período. El análisis del dataset proporciona una visión integral sobre la escala y la complejidad del problema de programación abordado.

\begin{table}[htbp]
    \centering
    \begin{tabular}{lc}
        \toprule
        \textbf{Atributo} & \textbf{Valor} \\
        \midrule
        Número total de tareas & 4.898 \\
        Número de órdenes de trabajo (OT) & 1.055 \\
        Fecha mínima & 2023/07/17 \\
        Fecha máxima & 2023/08/03 \\
        Duración promedio de tareas (horas) & 1,92 \\
        Número de cuadrillas & 31 \\
        Número de equipos auxiliares & 16 \\
        \bottomrule
    \end{tabular}
    \caption{Resumen de las características principales del dataset.}
    \label{tab:dataset_summary}
\end{table}


El conjunto de datos incluye un total de 4.898 tareas, distribuidas en 1,055 órdenes de trabajo (OT). Estas tareas abarcan un rango de tiempo desde el 17 de julio de 2023 hasta el 3 de agosto de 2023, lo que representa un período de planificación de poco más de dos semanas. La duración promedio de las tareas es de aproximadamente 1.92 horas, indicando que la mayoría de las actividades tienen una extensión corta, aunque hay una variación considerable en las duraciones específicas.

En términos de criticidad, las tareas se clasifican en tres niveles de impacto, donde 1 representa las tareas más críticas, 2 aquellas con una prioridad intermedia y 3 las de menor prioridad. La distribución de tareas según su criticidad es la siguiente:
\begin{itemize}
    \item \textbf{Criticidad 1 (Alta):} 666 tareas (13,6\% del total).
    \item \textbf{Criticidad 2 (Media):} 2.403 tareas (49.1\% del total).
    \item \textbf{Criticidad 3 (Baja):} 1.829 tareas (37,3\% del total).
\end{itemize}

El dataset también incluye información sobre los recursos disponibles para ejecutar las tareas. Estos recursos se dividen en dos categorías principales:
\begin{itemize}
    \item \textbf{Cuadrillas:} El dataset considera un total de 31 cuadrillas, cada una con su respectivo esquema de turnos y capacidades específicas.
    \item \textbf{Equipos Auxiliares:} Hay 16 equipos auxiliares disponibles, los cuales deben compartirse entre las diferentes cuadrillas, lo que añade restricciones significativas al problema de programación.
\end{itemize}

El rango temporal y las características de las tareas se resumen en la Tabla \ref{tab:dataset_summary}, mientras que la distribución de tareas según su criticidad se ilustra en la Figura~\ref{fig:barras_impacto}.


\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{imgs/barras_impacto.png}
    \caption{Distribución de tareas según su nivel de criticidad.}
    \label{fig:barras_impacto}
\end{figure}

Este dataset proporciona una base detallada y realista para el análisis y la implementación del modelo de programación, ya que combina un gran volumen de tareas con restricciones complejas y una diversidad de recursos. Además, la alta proporción de tareas con criticidad 1 y 2 subraya la importancia de optimizar el uso de los recursos para garantizar la ejecución de las tareas más críticas dentro de sus ventanas de tiempo establecidas

\subsection{Ajuste de Parámetros para la Función Objetivo}

La función objetivo del modelo combina dos componentes clave: el makespan, representado por el parámetro \( \alpha \), y la penalización por tareas no programadas, representada por el parámetro \( \beta \). Para determinar los valores más adecuados de \( \alpha \) y \( \beta \), se llevaron a cabo múltiples experimentos utilizando diferentes combinaciones de estos parámetros. El objetivo fue evaluar cómo cada configuración afecta el equilibrio entre la minimización del makespan y la cantidad de tareas programadas, especialmente aquellas con criticidad alta (impacto 1).

En estos experimentos, los resultados fueron analizados en función de métricas clave, incluyendo el número total de tareas programadas, la cantidad de tareas no programadas, el makespan obtenido, el tiempo de solución requerido y la cantidad de tareas no programadas según su nivel de impacto. Los resultados se presentan en dos tablas: la Tabla~\ref{tab:alpha_beta_general} resume las métricas generales, mientras que la Tabla~\ref{tab:alpha_beta_impact} detalla la distribución de tareas no programadas según su impacto.

\begin{table}[htbp]
    \centering
    \begin{tabular}{c>{\centering\arraybackslash}p{0.8cm} >{\centering\arraybackslash}p{0.8cm} 
                    >{\centering\arraybackslash}p{2.5cm} >{\centering\arraybackslash}p{2.5cm}
                    >{\centering\arraybackslash}p{2.5cm} >{\centering\arraybackslash}p{2.5cm}}
        \toprule
        \textbf{Conf.} & \( \alpha \) & \( \beta \) & 
        \makecell{\textbf{Tareas} \\ \textbf{Programadas}} & 
        \makecell{\textbf{Tareas no} \\ \textbf{Programadas}} & 
        \makecell{\textbf{Tiempo de} \\ \textbf{Solución (s)}} & 
        \textbf{Makespan} \\
        \midrule
        (a) & 1 & 0 & 0 & 4.898 & 3,43 & 0 \\
        (b) & 0 & 1 & 4.854 & 44 & 4,35 & 1.072 \\
        (c) & 1 & 1 & 4.658 & 240 & 8,42 & 492,75 \\
        (d) & 1 & 2 & 4.831 & 67 & 9,95 & 516,25 \\
        \bottomrule
    \end{tabular}
    \caption{Resultados generales obtenidos con diferentes configuraciones de \( \alpha \) y \( \beta \).}
    \label{tab:alpha_beta_general}
\end{table}


La configuración \( a \), donde \( \alpha = 1 \) y \( \beta = 0 \), prioriza exclusivamente la minimización del makespan. Sin embargo, este enfoque no logra programar ninguna tarea, lo que resulta inaceptable, ya que no se cumple el objetivo principal del modelo. Por otro lado, la configuración \( b \) (\( \alpha = 0 \), \( \beta = 1 \)) busca maximizar la cantidad de tareas programadas, logrando 4854 tareas en total. Aunque esta configuración presenta un makespan elevado (1072 unidades de tiempo), consigue programar todas las tareas de impacto 1, lo cual es un resultado favorable para las tareas más críticas.

La configuración \( c \) (\( \alpha = 1 \), \( \beta = 1 \)) equilibra ambos objetivos, pero a costa de una mayor cantidad de tareas no programadas (240). Si bien su makespan es menor que el de \( b \), su penalización por dejar tareas críticas fuera del cronograma lo hace menos atractivo.

Finalmente, la configuración \( d \) (\( \alpha = 1 \), \( \beta = 2 \)) logra un balance ideal entre los objetivos de programación y makespan. Con 4.831 tareas programadas, esta configuración deja fuera solo 67 tareas, manteniendo el makespan en un nivel razonable de 516,25 unidades de tiempo. Además, se asegura que todas las tareas de impacto 1 son programadas, mientras que las tareas de impacto 2 y 3 no programadas son reducidas al mínimo posible.

\begin{table}[htbp]
    \centering
    \begin{tabular}{c>{\centering\arraybackslash}p{1.5cm} >{\centering\arraybackslash}p{1.5cm} 
                    >{\centering\arraybackslash}p{1.5cm}}
        \toprule
        \textbf{Conf.} & \makecell{\textbf{Impacto} \\ \textbf{1}} & 
        \makecell{\textbf{Impacto} \\ \textbf{2}} & 
        \makecell{\textbf{Impacto} \\ \textbf{3}} \\
        \midrule
        (a) & 666 & 2.403 & 1.829 \\
        (b) & 0 & 8 & 36 \\
        (c) & 21 & 59 & 160 \\
        (d) & 0 & 12 & 55 \\
        \bottomrule
    \end{tabular}
    \caption{Distribución de tareas no programadas según su impacto.}
    \label{tab:alpha_beta_impact}
\end{table}


Se seleccionó la configuración \( d \) debido a su capacidad para satisfacer las prioridades del modelo. Aunque el tiempo de solución es el más alto entre las configuraciones evaluadas (9,95 segundos), este es un compromiso aceptable dado que garantiza un equilibrio óptimo entre la minimización del makespan y la programación de tareas críticas. Sin embargo, este tiempo de solución podría representar un desafío operativo en escenarios más grandes. Para abordar este problema, se propone utilizar la segmentación en subconjuntos, una técnica que divide el problema en partes más manejables, reduciendo así el tiempo de cálculo necesario para resolver cada subconjunto de tareas.

Para ilustrar el efecto de los diferentes valores de \( \alpha \) y \( \beta \), se incluye la Figura~\ref{fig:alpha_beta_analysis}, que muestra el trade-off entre tareas programadas y el makespan en función de las configuraciones evaluadas. Este gráfico resalta cómo la configuración \( d \) logra un equilibrio favorable en comparación con las demás opciones.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{imgs/sensibilidad_soluciones.png}
    \caption{Análisis de las configuraciones de \( \alpha \) y \( \beta \).}
    \label{fig:alpha_beta_analysis}
\end{figure}

En conclusión, la selección de \( \alpha = 1 \) y \( \beta = 2 \) se justifica por su desempeño superior en las métricas clave del modelo, alineándose con las prioridades operativas y estratégicas de la empresa. La implementación de la segmentación en subconjuntos permitirá optimizar aún más el tiempo de solución, asegurando que el modelo pueda escalar eficientemente a problemas más complejos.



\subsection{Resultados de la Segmentación en Subconjuntos}

La segmentación en subconjuntos permitió dividir el conjunto total de tareas en 14 subconjuntos más manejables, con el objetivo de reducir el tiempo de procesamiento del modelo. En la Tabla~\ref{tab:subsets_results} se presentan los resultados obtenidos, incluyendo el número de tareas en cada subconjunto, su porcentaje relativo con respecto al total (redondeado sin decimales) y el tiempo de solución requerido para resolver cada uno. Este análisis se llevó a cabo en un servidor virtual con las siguientes especificaciones:  

\begin{itemize}
    \item \textbf{vCPU/s:} 4 vCPUs.
    \item \textbf{RAM:} 8192 MB.
    \item \textbf{Almacenamiento:} 75 GB NVMe.
    \item \textbf{Sistema Operativo:} Ubuntu 24.10 x64.
\end{itemize}

\begin{table}[htbp]
    \centering
    \begin{tabular}{cccc}
        \toprule
        \textbf{Subconjunto} & \textbf{Número de Tareas} & \textbf{\% del Total} & \textbf{Tiempo de Solución (s)} \\
        \midrule
        \textit{S1} & 2.598 & 53\% & 4,34 \\
        \textit{S2} & 674 & 14\% & 0,65 \\
        \textit{S3} & 319 & 7\% & 0,43 \\
        \textit{S4} & 254 & 5\% & 0,12 \\
        \textit{S5} & 198 & 4\% & 0,01 \\
        \textit{S6} & 136 & 3\% & 0,01 \\
        \textit{S7} & 122 & 2\% & 0,00 \\
        \textit{S8} & 110 & 2\% & 0,01 \\
        \textit{S9} & 98 & 2\% & 0,00 \\
        \textit{S10} & 87 & 2\% & 0,00 \\
        \textit{S11} & 84 & 2\% & 0,01 \\
        \textit{S12} & 78 & 2\% & 0,00 \\
        \textit{S13} & 72 & 1\% & 0,00 \\
        \textit{S14} & 68 & 1\% & 0,00 \\
        \bottomrule
    \end{tabular}
    \caption{Resultados de la segmentación en subconjuntos.}
    \label{tab:subsets_results}
\end{table}


La segmentación produjo un subconjunto principal, \( S1 \), que contiene 2.598 tareas, representando el 53\% del total. Este subconjunto, al abarcar más de la mitad de las tareas, requirió el mayor tiempo de solución (4,34 segundos). Los otros 13 subconjuntos contienen entre 68 y 674 tareas cada uno, con porcentajes significativamente menores del total. El segundo subconjunto más grande, \( S2 \), con 674 tareas (14\%), presentó un tiempo de solución de 0,65 segundos, destacando la eficiencia del enfoque modular al abordar subconjuntos de menor tamaño. Los subconjuntos más pequeños, desde \( S5 \) hasta \( S14 \), contienen menos del 5\% de las tareas totales cada uno y se resolvieron en tiempos cercanos a cero segundos.

El procesamiento de los subconjuntos se llevó a cabo de manera paralela, aprovechando las capacidades del servidor. Como resultado, el tiempo total de solución se igualó al máximo tiempo de solución de todos los subconjuntos, es decir, 4,34 segundos. Este enfoque demostró la ventaja de dividir el problema en partes independientes y resolverlas simultáneamente, reduciendo considerablemente el tiempo total necesario para obtener los resultados.

El análisis de los resultados muestra que más del 50\% de las tareas están concentradas en un único subconjunto (\( S1 \)), mientras que los demás subconjuntos están distribuidos de manera desigual, con tamaños decrecientes. Esta concentración sugiere que ciertas tareas comparten fuertes conexiones o restricciones comunes, explicando la formación de un subconjunto dominante. Aunque \( S1 \) tiene un impacto significativo en el desempeño general, el tiempo total de cálculo resulta eficiente y adecuado gracias al enfoque de paralelización.

En conclusión, la segmentación en subconjuntos demostró ser una estrategia efectiva para mejorar el tiempo de solución del modelo, permitiendo resolver problemas complejos en tiempos razonables. El tiempo total de solución se igualó al del subconjunto más grande (4,34 segundos), gracias al procesamiento paralelo.

\section{Conclusiones y Pasos a Seguir}


Los resultados obtenidos muestran que el modelo desarrollado cumple con las expectativas de la empresa colaboradora, proporcionando una solución eficiente y satisfactoria para la programación automatizada de actividades de mantenimiento. Se logra un cronograma que cumple con las condiciones y restricciones definidas, en tiempos de procesamiento acotados y manejables.

El modelo logra un equilibrio entre la minimización del makespan y la programación de tareas críticas. La segmentación en subconjuntos se revela como una estrategia efectiva para reducir el tiempo de cálculo, permitiendo resolver problemas complejos en tiempos razonables y escalables.

Para nuestro dataset de 4.898 tareas, el modelo logra programar el 98,6\% de las tareas, dejando solo 67 tareas no programadas. Además, se garantiza la programación de todas las tareas de impacto 1, lo que refleja la priorización de las actividades más críticas. El makespan obtenido es de 516,25 horas, lo que indica una distribución eficiente de las tareas en el tiempo disponible.


\begin{figure}[htbp]
    \centering
    \frame{\includegraphics[scale=0.3]{imgs/gantt-project.jpg}}
    \caption{Captura de Cronograma Resultante en MS Project}
    \label{fig:gantt-project}
  \end{figure}
  
  

Con base en una encuesta realizada al personal de programación de la empresa colaboradora, se evidenció que el proceso actual de programación de actividades podría beneficiarse significativamente de herramientas que automatizan partes clave del flujo de trabajo. En particular, una herramienta que automatice la creación del borrador inicial del cronograma y permita la incorporación fluida de cambios de último minuto, ajustes derivados de conflictos de recursos y validaciones con otras áreas, sería altamente valorada.

Se estima que una herramienta con estas características podría \textbf{reducir hasta en un 50\% el tiempo que el equipo de programación dedica a estas tareas}. Esto optimizaría la asignación de su tiempo, permitiéndoles enfocarse en actividades estratégicas.

Para garantizar el éxito de esta herramienta, será fundamental su integración con las fuentes de información de otras áreas de la empresa. En particular:
\begin{itemize}
    \item Conexión con el área de planificación para acceder a información clave sobre las tareas: requerimientos de recursos, ventanas de tiempo y restricciones operativas.
    \item Integración con el sistema de bodega para garantizar la disponibilidad de materiales y repuestos.
    \item Conexión con los datos de disponibilidad de equipos y cuadrillas.
\end{itemize}

Además, será necesario revisar y ajustar los procedimientos internos de estas áreas para garantizar que la información sea precisa y confiable. Si se logra implementar una herramienta que integre estas funcionalidades y asegure la calidad de los datos, se estima que \textbf{los errores en las labores de mantenimiento derivados de una programación deficiente podrían reducirse en un 75\%}.

\subsection{Pasos a Seguir}

Es importante mencionar que el desarrollo del modelo y su implementación en un entorno operativo real requiere de una serie de pasos adicionales. A continuación, se detallan las recomendaciones para la implementación exitosa de la solución propuesta.

La solución se desarrolla de manera modular, estructurándose en tres componentes principales: el backend, el frontend y la integración con las plataformas de la empresa. Esta división permite organizar el flujo de trabajo de forma eficiente y facilita la colaboración con el equipo técnico de la empresa, asegurando que la solución se adapte adecuadamente a sus necesidades.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.3]{imgs/ModulosDesarrollo.png}
  \caption{Módulos de Desarrollo de Solución}
  \label{fig:modulos-desarrollo}
\end{figure}

\subsubsection{Backend}

El backend representa el núcleo funcional de la solución y ejecuta el algoritmo de programación automatizada de tareas. Este algoritmo se selecciona en función de su capacidad para generar resultados de alta calidad que cumplan con las restricciones y optimicen la programación de tareas según los objetivos planteados. El backend recibe como entrada los datos de las órdenes de trabajo, que incluyen la información específica de cada tarea, tales como duraciones, recursos necesarios, precedencias y ventanas de tiempo.

El backend se implementará en Python, utilizando \textbf{FastAPI} como framework para exponer los endpoints REST necesarios. Para el motor de optimización, se empleará \textbf{OR-Tools} para resolver el problema mediante Programación por Restricciones (CP-SAT) u otros métodos heurísticos evaluados previamente. El almacenamiento de datos se manejará con \textbf{PostgreSQL}, alojado en un entorno cloud escalable.

El servicio será desplegado en un clúster de \textbf{Kubernetes} en \textbf{Azure Kubernetes Service (AKS)}, aprovechando su capacidad de escalabilidad automática y alta disponibilidad. El contenedor del backend se construirá utilizando \textbf{Docker}, con un pipeline de integración continua configurado en \textbf{Azure DevOps} para automatizar pruebas y despliegues.

\subsubsection{Frontend}

El frontend funcionará como la interfaz principal para los programadores de la empresa, quienes son los usuarios de esta solución. El diseño estará enfocado en la facilidad de uso, permitiendo que los programadores carguen los datos de las órdenes de trabajo de manera sencilla. La carga de datos podrá realizarse de manera manual o mediante integración con el sistema ERP de la empresa.

El frontend será desarrollado en \textbf{React.js}, utilizando librerías como \textbf{React-Gantt-Chart} o \textbf{D3.js} para generar gráficos interactivos de Gantt que permitan la visualización y ajuste manual de los cronogramas generados. Además, el frontend permitirá a los usuarios exportar el cronograma a formatos compatibles con \textit{Microsoft Project} y Excel.

Este módulo será desplegado como una aplicación web estática en \textbf{Azure App Service}, conectándose con el backend a través de los endpoints expuestos por FastAPI. La seguridad de la comunicación se garantizará mediante certificados SSL proporcionados por \textbf{Azure Key Vault}.

\subsubsection{Integración con Plataformas de la Empresa}

El tercer módulo se encargará de la integración con las plataformas existentes de la empresa. Este módulo se desarrollará en estrecha colaboración con el equipo de TI de la organización para garantizar la compatibilidad de los formatos de entrada y salida con los sistemas actuales, incluyendo el ERP.

La integración será bidireccional, permitiendo:
\begin{itemize}
    \item La importación automática de datos sobre órdenes de trabajo, disponibilidad de cuadrillas y recursos desde el ERP.
    \item La exportación del cronograma final a los sistemas existentes para su validación y distribución.
\end{itemize}

Se configurarán conexiones seguras mediante protocolos estándar como \textit{OAuth 2.0} y \textit{HTTPS}. Además, el uso de \textbf{Azure API Management} facilitará el monitoreo y la administración de las APIs involucradas.

\subsection{Arquitectura de la Solución}

La arquitectura propuesta combina herramientas modernas de desarrollo y gestión de infraestructura para garantizar escalabilidad, disponibilidad y seguridad. En la Figura~\ref{fig:arquitectura-solucion} se detalla la arquitectura general de la solución, implementada en \textbf{Microsoft Azure}.

\begin{figure}[htbp]
  \centering
  \frame{\includegraphics[scale=0.3]{imgs/blank.png}}
  \caption{Arquitectura Propuesta de la Solución}
  \label{fig:arquitectura-solucion}
\end{figure}

\begin{itemize}
    \item \textbf{Backend:} Contenedorizado con \textbf{Docker} y desplegado en un clúster de \textbf{Azure Kubernetes Service (AKS)}, con una base de datos \textbf{PostgreSQL} alojada en \textbf{Azure Database for PostgreSQL}.
    \item \textbf{Frontend:} Aplicación web estática desplegada en \textbf{Azure App Service}, integrada con el backend mediante endpoints REST.
    \item \textbf{Integración:} APIs gestionadas mediante \textbf{Azure API Management}, conectadas con sistemas corporativos y almacenamientos adicionales en \textbf{Azure Blob Storage}.
    \item \textbf{Seguridad:} Certificados SSL y claves gestionadas en \textbf{Azure Key Vault}.
    \item \textbf{Monitoreo:} Métricas y logs gestionados mediante \textbf{Azure Monitor}.
\end{itemize}

\subsection{Próximos Pasos}

\begin{itemize}
    \item Realizar un plan detallado de desarrollo basado en la arquitectura propuesta, incluyendo estimaciones de tiempo para cada módulo.
    \item Implementar pruebas unitarias y de integración para garantizar la calidad del software en todas las etapas de desarrollo.
    \item Capacitar al equipo de la empresa en el uso de la solución, asegurando una transición fluida hacia el nuevo sistema.
    \item Monitorear el desempeño del sistema una vez implementado, recolectando retroalimentación para futuras mejoras.
\end{itemize}



\subsection{Conclusión Final}  
El modelo desarrollado representa un avance significativo en la automatización de la programación de actividades de mantenimiento, con el potencial de optimizar el flujo de trabajo, reducir errores y mejorar la eficiencia operativa. La implementación de los pasos a seguir garantizará que esta solución pase de ser un prototipo a una herramienta integrada y funcional que genere un impacto tangible en las operaciones de la empresa colaboradora.


\newpage

\begin{appendix}
    \section{Resultados Encuesta sobre Programación de Actividades en el Área de Mantenimiento de la empresa colaboradora}
    \label{anexo:encuesta}

    \section*{Resumen Ejecutivo}

    Se realizó una encuesta a programadores del área de mantenimiento 6 operaciones de la empresa colaboradora, con el objetivo de identificar los principales desafíos y oportunidades de mejora en el proceso de programación. La encuesta abordó aspectos como dedicación horaria, actividades realizadas, errores comunes y problemas asociados a la coordinación.
    
    Las principales conclusiones son:
    
    \begin{itemize}
        \item \textbf{Alta dedicación horaria}: 64\% de los encuestados invierte más de la mitad de su jornada semanal en generación del cronograma de actividades.
        \item \textbf{La creación del borrador inicial} es la fase más intensiva en tiempo, superando otras actividades como resolver conflictos o validar con otras áreas.
        \item \textbf{La no disponibilidad de materiales y repuestos} durante la ejecución de las mantenciones es el error más recurrente.
        \item \textbf{Entorno altamente dinámico}: El 90\% de los encuestados enfrenta cambios de último minuto al menos una vez por semana.
        \item \textbf{Problemas de coordinación con otras áreas} y \textbf{falta de colaboración} son barreras adicionales que dificultan la programación eficiente.
    \end{itemize}
    
    Los resultados de la encuesta muestran que el proceso de programación podría beneficiarse significativamente de herramientas que automaticen partes claves del proceso. Una herramienta de automatización que permita generar el borrador inicial del cronograma, incorporar facilmente cambios de último minuto y realizar ajustes derivados de conflictos de recursos o validaciones \textbf{podría reducir en un 50\% la dedicación horaria del equipo de programación} en lo que respecta a la creación del cronograma de tareas. 
    
    Su éxito dependerá de su integración con las fuentes de información adecuadas, especialmente con bodega, para garantizar la disponibilidad de materiales y repuestos. Con información precisa y confiable, esta herramienta también \textbf{podría disminuir hasta en un 75\% los errores en las labores de mantenimiento derivados de una programación deficiente}.
    
    \section*{Metodología}
    
    La encuesta se aplicó a un total de 19 programadores de 6 operaciones de la empresa colaboradora, mediante una plataforma on-line, durante el mes de Diciembre de 2024. Se trató de un cuestionario breve, compuesto por 7 preguntas. La mediana del tiempo de respuesta fue de aproximadamente 5 minutos y 30 segundos. 
    
    Las preguntas estuvieron diseñadas para estimar el tiempo dedicado a la programación, la distribución de dicho tiempo entre distintas actividades, la frecuencia e impacto de errores, y las condiciones cambiantes que inciden en la planificación.
    
    A continuación se presentan los resultados y el análisis de las respuestas obtenidas.
    
    \section*{Resultados de la Encuesta}
    
    En esta sección se presentan las preguntas realizadas a los encuestados junto con una tabla que resume los resultados obtenidos. Posteriormente, se incluye un comentario que analiza los datos presentados y destaca las principales conclusiones relacionadas con cada pregunta.
    
    \vspace{.5em}
    \subsubsection*{Pregunta 1: ¿Cuántas horas a la semana dedica el equipo de programación a generar el cronograma de tareas?}
    
    
    
    \begin{table}[htbp]
        \centering
        \begin{tabular}{lcc}
            \toprule
            \textbf{Rango de horas} & \textbf{Porcentaje} & \textbf{Cantidad} \\
            \midrule
            Menos de 10 horas & 5\% & 1 \\
            Entre 10 y 20 horas & 32\% & 6 \\
            Entre 20 y 40 horas & 53\% & 10 \\
            Más de 40 horas & 11\% & 2 \\
            \bottomrule
        \end{tabular}
        \label{tab:horas_semanales}
    \end{table}
    
    \paragraph{Comentario} Es notable que más de la mitad de los encuestados (53\%) dedica entre 20 y 40 horas semanales a la programación. Esto sugiere que la generación del cronograma de tareas consume una parte significativa de la jornada: en 64\% de los casos, más de la mitad de la semana laboral.
    
    
    \vspace{1.5em}
    \subsubsection*{Pregunta 2: ¿Qué porcentaje del tiempo total de programación está dedicado a las siguientes actividades?}
    \vspace{.5em}
    
    \begin{table}[htbp]
        \centering
        \begin{tabular}{lccc c}
            \toprule
            \textbf{Actividad} & \textbf{Promedio (\%)} & \textbf{Mínimo (\%)} & \textbf{Máximo (\%)} \\
            \midrule
            Generar el borrador inicial & 34.8 & 0 & 66\\
            Resolver conflictos de recursos & 23.8 & 10 & 70\\
            Validar con otras áreas & 19.7 & 10 & 40\\
            Realizar ajustes finales & 21.7 & 0 & 50\\
            \bottomrule
        \end{tabular}
        \label{tab:distribucion_actividades}
    \end{table}
    
    \paragraph{Comentario} Alrededor del 35\% del tiempo total de programación se concentra en la generación del borrador inicial, convirtiéndose en la actividad más demandante. Le siguen la resolución de conflictos de recursos y la realización de ajustes finales, con promedios cercanos al 24\% y 22\%, respectivamente. Cabe destacar que algunas personas reportan dedicar un 0\% de su tiempo a generar el borrador inicial o a realizar ajustes finales, lo que sugiere que estas etapas pueden ser asumidas por otras áreas o que ciertos roles se centran exclusivamente en validaciones o resolución de conflictos.
    
    \vspace{1.5em}
    \subsubsection*{Pregunta 3: ¿Cuántas personas del equipo participan activamente en la programación y qué porcentaje de su jornada diaria dedican a esta actividad?}
    
    A partir del análisis de las 19 respuestas obtenidas, se observa una gran variabilidad en el porcentaje de jornada diaria dedicado a la programación y en el número de personas involucradas. Las estadísticas resumen se presentan en la siguiente tabla:
    
    \begin{table}[htbp]
        \centering
        \begin{tabular}{lcc}
            \toprule
            & \textbf{Promedio} & \textbf{Desviación Estándar} \\
            \midrule
            Número de personas & 2.8 & 1.5 \\
            Porcentaje de jornada diaria (\%) & 64.2 & 30.3 \\
            \bottomrule
        \end{tabular}
        \label{tab:estadisticas_resumen_jornada}
    \end{table}
    
    \paragraph{Comentario} Estos resultados reflejan una dispersión significativa: en algunos casos, un equipo reducido (2 personas) dedica el 100\% de su jornada a la programación, mientras que en otros equipos, más numerosos, el porcentaje de tiempo invertido es mucho menor.
    
    
    \vspace{1.5em}
    \subsubsection*{Pregunta 4: ¿Con qué frecuencia ocurren cambios de último minuto en las tareas o recursos disponibles?}
    
    \begin{table}[htbp]
        \centering
        \begin{tabular}{lcc}
            \toprule
            \textbf{Frecuencia} & \textbf{Porcentaje} & \textbf{Cantidad} \\
            \midrule
            Varias veces por semana & 42\% & 8 \\
            Semanalmente & 47\% & 9 \\
            Pocas veces al mes & 5\% & 1 \\
            Rara vez & 5\% & 1 \\
            \bottomrule
        \end{tabular}
        \label{tab:cambios_ultimo_minuto}
    \end{table}
    
    \paragraph{Comentario} Casi un 90\% del equipo enfrenta cambios de último minuto al menos una vez por semana. Esto evidencia un entorno altamente dinámico y la dificultad de anteponerse a los imprevistos en el proceso de programación.
    
    
    \vspace{1.5em}
    \subsubsection*{Pregunta 5: Cuál de estos errores es el más comun durante el proceso de programación?}
    
    \begin{table}[htbp]
        \centering
        \begin{tabular}{p{7cm}cc}
            \toprule
            \textbf{Tipo de error} & \textbf{Porcentaje} & \textbf{Cantidad} \\
            \midrule
            Cuadrilla no disponible & 0\% & 0 \\
            Herramientas o Equipos no disponibles & 16\% & 3 \\
            Naves o Talleres no disponibles & 0\% & 0 \\
            Materiales o Repuestos no disponibles & 74\% & 14 \\
            Omisión de tareas críticas & 0\% & 0 \\
            El equipo sobre el cual se programó la mantención se encuentra ocupado & 11\% & 2 \\
            \bottomrule
        \end{tabular}
        \label{tab:errores_comunes}
    \end{table}
    
    \paragraph{Comentario} Lejos, el problema más recurrente identificado por los encuestados es la falta de materiales o repuestos disponibles, con un 74\% de respuestas. En segundo lugar, se encuentra la falta de herramientas o equipos disponibles; y en tercer la coordinación deficiente que genera conflictos al programar mantenciones en equipos ocupados.
    
    Por otro lado, es destacable que algunos factores potencialmente problemáticos, como la falta de cuadrillas o de talleres disponibles, no representan un obstáculo en este contexto, ya que ninguno de los encuestados los señaló como fuente de errores. De manera similar, la omisión de tareas críticas tampoco parece ser un problema recurrente, lo que sugiere que estos asuntos se encuentran relativamente resueltas en el proceso actual.
    
    \vspace{1.5em}
    \subsubsection*{Pregunta 6: ¿Qué otros errores considera que podrían ocurrir durante el proceso de programación?}
    
    Las respuestas a esta pregunta abierta señalaron como errores adicionales frecuentes la falta de coordinación con otras áreas, la inclusión de actividades de último minuto, y las dificultades para coordinar a los diferentes especialistas involucrados en una tarea. También se mencionaron problemas relacionados con la falta de repuestos y la indisponibilidad de equipos auxiliares, fechas de mantenciones variables, y cambios operacionales o provenientes de otras áreas. Además, se destacó la información deficiente desde bodega en relación con los repuestos.
    
    \paragraph{Comentario} En conjunto, estas respuestas cualitativas confirman nuevamente la existencia de problemas significativos relacionados con la disponibilidad de materiales y repuestos, en gran parte vinculados a la información deficiente proporcionada por bodega. Sin embargo, también se destacan con frecuencia los problemas de coordinación con otras áreas, que reflejan desafíos relacionados con la alineación de procesos y la colaboración entre equipos.
    
    \vspace{1.5em}
    \subsubsection*{Pregunta 7: En promedio, ¿cuántos de estos errores ocurren por mes?}
    
    \begin{table}[htbp]
        \centering
        \begin{tabular}{p{7cm}cccc}
            \toprule
            \textbf{Tipo de error} & \textbf{Promedio} & \textbf{Mínimo} & \textbf{Máximo} \\
            \midrule
            Cuadrilla no disponible & 3.5 & 0 & 10 \\
            Herramientas o equipos no disponibles & 3.9 & 1 & 12 \\
            Naves o talleres no disponibles & 2.7 & 0 & 10 \\
            Omisión de tareas críticas & 2.4 & 0 & 6 \\
            El equipo sobre el cual se programó la mantención se encuentra ocupado & 3.9 & 1 & 12 \\
            Materiales o repuestos no disponibles & 6.3 & 1 & 14 \\
            \bottomrule
        \end{tabular}
        \label{tab:errores_especificos}
    \end{table}
    
    \paragraph{Comentario}La falta de materiales o repuestos disponibles vuelve a ser un factor crítico, con un promedio superior a 6 eventos por mes. Esto confirma la relevancia de contar con información fidedigna e integrada sobre la disponibilidad de recursos para mejorar la eficiencia del proceso de programación. Le siguen en frecuencia la falta de herramientas o equipos disponibles y la ocupación de los equipos programados para mantenciones, con un promedio de 3.9 eventos por mes cada uno.
    
    \section*{Análisis y Conclusiones}
    
    El análisis de los resultados de la encuesta resalta varios aspectos críticos que afectan el proceso de programación de las actividades de mantenimiento de la empresa colaboradora. Entre los hallazgos principales, destaca la alta dedicación horaria, con un 64\% de los encuestados invirtiendo más de la mitad de su jornada semanal en la generación del cronograma de tareas. La creación del borrador inicial se identifica como la etapa más demandante, representando en promedio el 35\% del tiempo total dedicado.
    
    El entorno de programación se caracteriza por ser altamente dinámico, con el 90\% de los encuestados reportando cambios de último minuto al menos semanalmente. Los errores más recurrentes están relacionados con la disponibilidad de materiales y repuestos, mencionados por el 74\% de los participantes, seguidos por la falta de herramientas y equipos auxiliares. Adicionalmente, los problemas de coordinación con otras áreas y la falta de colaboración surgen como barreras relevantes que dificultan la planificación efectiva.
    
    Los resultados de la encuesta muestran que el proceso de programación de actividades de mantenimiento \uline{podría beneficiarse significativamente de herramientas que automatizan partes clave del proceso}. En particular, una herramienta que automatice la creación del borrador inicial del cronograma y que permita incorporar de forma fluida cambios de último minuto o ajustes derivados de la resolución de conflictos de recursos y validaciones con otras áreas sería altamente efectiva. Una herramienta de este tipo, que facilite la incorporación rápida de modificaciones, \textbf{podría reducir hasta en un 50\% la dedicación horaria} de los equipos de programación a esta tarea, optimizando el uso de su tiempo.
    
    El éxito de esta herramienta, sin embargo, dependerá en gran medida de su integración con las fuentes de información de otras áreas de la empresa. En particular, será esencial conectarla con el área de planificación para acceder a información crítica sobre las tareas, como sus requerimientos de recursos, ventanas de tiempo (fechas de inicio más tempranas y fechas requeridas), y restricciones operativas. Además, será crucial integrarla con la información de bodega para garantizar la disponibilidad de materiales y repuestos, así como también con los datos sobre la disponibilidad de equipos. Es posible que se necesite revisar y ajustar los procedimientos de estas áreas para garantizar que la información sea precisa y confiable. Si se logra implementar una herramienta que integre estas funcionalidades y asegure la calidad de los datos, los \textbf{errores en las labores de mantenimiento derivados de una programación deficiente podrían reducirse en alrededor de un 75\%}.
    
    
\end{appendix}

\printbibliography

\end{document}
